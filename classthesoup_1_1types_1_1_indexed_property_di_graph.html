<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Numeric: thesoup::types::IndexedPropertyDiGraph&lt; V_TYPE, E_TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Numeric<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">A C++ numeric library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacethesoup.html">thesoup</a></li><li class="navelem"><a class="el" href="namespacethesoup_1_1types.html">types</a></li><li class="navelem"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">IndexedPropertyDiGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classthesoup_1_1types_1_1_indexed_property_di_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">thesoup::types::IndexedPropertyDiGraph&lt; V_TYPE, E_TYPE &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A property graph type with indices into the vertices and edge types.  
 <a href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="indexedgraph_8hpp_source.html">indexedgraph.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for thesoup::types::IndexedPropertyDiGraph&lt; V_TYPE, E_TYPE &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classthesoup_1_1types_1_1_indexed_property_di_graph.png" usemap="#thesoup::types::IndexedPropertyDiGraph_3C_20V_5FTYPE_2C_20E_5FTYPE_20_3E_map" alt=""/>
  <map id="thesoup::types::IndexedPropertyDiGraph_3C_20V_5FTYPE_2C_20E_5FTYPE_20_3E_map" name="thesoup::types::IndexedPropertyDiGraph_3C_20V_5FTYPE_2C_20E_5FTYPE_20_3E_map">
<area href="classthesoup_1_1types_1_1_graph.html" alt="thesoup::types::Graph&lt; IndexedPropertyDiGraph&lt; V_TYPE, E_TYPE &gt;, V_TYPE, E_TYPE, IndexedPropertyDiGraphAttributes::ErrorCode, std::size_t, std::size_t &gt;" shape="rect" coords="0,0,932,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f298b5ca1c8ee50a04113e8a5336f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::size_t, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#a2f298b5ca1c8ee50a04113e8a5336f1c">register_edge_type</a> (const E_TYPE &amp;edge) noexcept</td></tr>
<tr class="memdesc:a2f298b5ca1c8ee50a04113e8a5336f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an edge.  <br /></td></tr>
<tr class="separator:a2f298b5ca1c8ee50a04113e8a5336f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79edb216c8ed3509d6f93a17306444a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::size_t, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#aa79edb216c8ed3509d6f93a17306444a">insert_vertex</a> (const V_TYPE &amp;vertex) noexcept</td></tr>
<tr class="memdesc:aa79edb216c8ed3509d6f93a17306444a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a vertex.  <br /></td></tr>
<tr class="separator:aa79edb216c8ed3509d6f93a17306444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bdb5e7e7efd935be742b827ecdb6b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#a00bdb5e7e7efd935be742b827ecdb6b4">delete_vertex</a> (const std::size_t &amp;vertex) noexcept</td></tr>
<tr class="memdesc:a00bdb5e7e7efd935be742b827ecdb6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a vertex.  <br /></td></tr>
<tr class="separator:a00bdb5e7e7efd935be742b827ecdb6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc0b427058a4eea5f24e1b6c5b72e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; const V_TYPE, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#a3dc0b427058a4eea5f24e1b6c5b72e2f">hydrate_vertex</a> (const std::size_t &amp;vertex_id) const noexcept</td></tr>
<tr class="memdesc:a3dc0b427058a4eea5f24e1b6c5b72e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hydrate a vertex.  <br /></td></tr>
<tr class="separator:a3dc0b427058a4eea5f24e1b6c5b72e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c18209d744a2c033910c7923adb9a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#a3c18209d744a2c033910c7923adb9a0d">insert_edge</a> (const <a class="el" href="structthesoup_1_1types_1_1_edge.html">thesoup::types::Edge</a>&lt; std::size_t, std::size_t &gt; &amp;edge) noexcept</td></tr>
<tr class="memdesc:a3c18209d744a2c033910c7923adb9a0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge.  <br /></td></tr>
<tr class="separator:a3c18209d744a2c033910c7923adb9a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf6c6457bf485708f46cc8f3d0bca0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#a0bf6c6457bf485708f46cc8f3d0bca0c">delete_edge</a> (const <a class="el" href="structthesoup_1_1types_1_1_edge.html">thesoup::types::Edge</a>&lt; std::size_t, std::size_t &gt; &amp;edge) noexcept</td></tr>
<tr class="memdesc:a0bf6c6457bf485708f46cc8f3d0bca0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete an edge.  <br /></td></tr>
<tr class="separator:a0bf6c6457bf485708f46cc8f3d0bca0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a18b746016dc415f0cd8b3d9035270"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; const E_TYPE, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#ad5a18b746016dc415f0cd8b3d9035270">hydrate_edge_type</a> (const std::size_t &amp;edge_type_id) const noexcept</td></tr>
<tr class="memdesc:ad5a18b746016dc415f0cd8b3d9035270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hydrate an edge type.  <br /></td></tr>
<tr class="separator:ad5a18b746016dc415f0cd8b3d9035270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d6129ec38119e0feb0c11f5d1c8862d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::vector&lt; <a class="el" href="structthesoup_1_1types_1_1_neighbour.html">thesoup::types::Neighbour</a>&lt; std::size_t, std::size_t &gt; &gt;, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#a9d6129ec38119e0feb0c11f5d1c8862d">get_neighbours</a> (const std::size_t &amp;vertex) const noexcept</td></tr>
<tr class="memdesc:a9d6129ec38119e0feb0c11f5d1c8862d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all neighbours of a vertex.  <br /></td></tr>
<tr class="separator:a9d6129ec38119e0feb0c11f5d1c8862d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df0191bd334ccde77052b018e7db630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::vector&lt; std::size_t &gt;, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html#a1df0191bd334ccde77052b018e7db630">get_neighbours</a> (const std::size_t &amp;vertex, const std::size_t &amp;edge_type)</td></tr>
<tr class="memdesc:a1df0191bd334ccde77052b018e7db630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all neighbour of a vertex, attached by a given edge type.  <br /></td></tr>
<tr class="separator:a1df0191bd334ccde77052b018e7db630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classthesoup_1_1types_1_1_graph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classthesoup_1_1types_1_1_graph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classthesoup_1_1types_1_1_graph.html">thesoup::types::Graph&lt; IndexedPropertyDiGraph&lt; V_TYPE, E_TYPE &gt;, V_TYPE, E_TYPE, IndexedPropertyDiGraphAttributes::ErrorCode, std::size_t, std::size_t &gt;</a></td></tr>
<tr class="memitem:ac8bf9fa8af23bbe28203c3e3becc632c inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a id="ac8bf9fa8af23bbe28203c3e3becc632c" name="ac8bf9fa8af23bbe28203c3e3becc632c"></a>
<a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::vector&lt; <a class="el" href="structthesoup_1_1types_1_1_neighbour.html">Neighbour</a>&lt; std::size_t, std::size_t &gt; &gt;, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbours</b> (const std::size_t &amp;vertex) const noexcept</td></tr>
<tr class="separator:ac8bf9fa8af23bbe28203c3e3becc632c inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4f28065a649239571c0e08f5b70c58 inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a id="a4f4f28065a649239571c0e08f5b70c58" name="a4f4f28065a649239571c0e08f5b70c58"></a>
<a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::vector&lt; std::size_t &gt;, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_neighbours</b> (const std::size_t &amp;vertex, const std::size_t &amp;edge_type) const noexcept</td></tr>
<tr class="separator:a4f4f28065a649239571c0e08f5b70c58 inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578c5c0971511627328533774d360e15 inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a id="a578c5c0971511627328533774d360e15" name="a578c5c0971511627328533774d360e15"></a>
<a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::size_t, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_vertex</b> (const V_TYPE &amp;vertex) noexcept</td></tr>
<tr class="separator:a578c5c0971511627328533774d360e15 inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986e2cdd7603c655bc2f582a3b18b4da inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a id="a986e2cdd7603c655bc2f582a3b18b4da" name="a986e2cdd7603c655bc2f582a3b18b4da"></a>
<a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>insert_edge</b> (const <a class="el" href="structthesoup_1_1types_1_1_edge.html">Edge</a>&lt; std::size_t, std::size_t &gt; &amp;edge) noexcept</td></tr>
<tr class="separator:a986e2cdd7603c655bc2f582a3b18b4da inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587ac9c8a283a31197eba96b8871b70 inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a id="a6587ac9c8a283a31197eba96b8871b70" name="a6587ac9c8a283a31197eba96b8871b70"></a>
<a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>delete_vertex</b> (const std::size_t &amp;vertex) noexcept</td></tr>
<tr class="separator:a6587ac9c8a283a31197eba96b8871b70 inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a5e274514cd3fd82592397e8720868 inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memItemLeft" align="right" valign="top"><a id="a42a5e274514cd3fd82592397e8720868" name="a42a5e274514cd3fd82592397e8720868"></a>
<a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>delete_edge</b> (const <a class="el" href="structthesoup_1_1types_1_1_edge.html">Edge</a>&lt; std::size_t, std::size_t &gt; &amp;edge) noexcept</td></tr>
<tr class="separator:a42a5e274514cd3fd82592397e8720868 inherit pub_methods_classthesoup_1_1types_1_1_graph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename V_TYPE, typename E_TYPE&gt;<br />
class thesoup::types::IndexedPropertyDiGraph&lt; V_TYPE, E_TYPE &gt;</div><p>A property graph type with indices into the vertices and edge types. </p>
<p>This class implements the <a class="el" href="classthesoup_1_1types_1_1_graph.html" title="An interface for a graph class.">thesoup::types::Graph</a> interface with some extra functionality, and using <code>std::size_t</code> as the <code>VID_TYPE</code> and <code>EID_TYPE</code>. This graph models vertices of type V_TYPE connected by "properties". A good use case id RDF graph, where the subject and object are vertices of V_TYPE and the predicate if of the type E_TYPE. Since in RDF graphs the predicates are highly repeated, we are better off "registering" a predicate once (using the register_edge_type method) and using the returned ID (std::size_t) again and again in the actual graph.</p>
<p>Similarly for vertices, when we insert a vertex, an ID (std::size_t) is returned that then we use to construct the actual graph. Since we expose the IDs to the user, traversal operations and hydration can be decoupled, resulting in good performance opportunities.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">V_TYPE</td><td>The vertex type </td></tr>
    <tr><td class="paramname">E_TYPE</td><td>The edge type </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0bf6c6457bf485708f46cc8f3d0bca0c" name="a0bf6c6457bf485708f46cc8f3d0bca0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf6c6457bf485708f46cc8f3d0bca0c">&#9670;&#160;</a></span>delete_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::delete_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structthesoup_1_1types_1_1_edge.html">thesoup::types::Edge</a>&lt; std::size_t, std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete an edge. </p>
<p>This method deletes an edge from the graph. NOTE: The edge type is not effected by this method. If the edge is invalid because on of both of the vertices does not exist, an error is returned. If the edge type happens to be invalid of the edge does not exist, an error is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result&lt;Unit, ErrorCode&gt; </dd></dl>

</div>
</div>
<a id="a00bdb5e7e7efd935be742b827ecdb6b4" name="a00bdb5e7e7efd935be742b827ecdb6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bdb5e7e7efd935be742b827ecdb6b4">&#9670;&#160;</a></span>delete_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::delete_vertex </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a vertex. </p>
<p>This method accepts a vertex ID and delete the vertex both from the index and the graph. If the vertex does not exist, an error specifying that is returned. Also, if a vertex is connected to something, it will not be deleted. An error specifying that will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result&lt;Unit, ErrorCode&gt; </dd></dl>

</div>
</div>
<a id="a9d6129ec38119e0feb0c11f5d1c8862d" name="a9d6129ec38119e0feb0c11f5d1c8862d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d6129ec38119e0feb0c11f5d1c8862d">&#9670;&#160;</a></span>get_neighbours() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::vector&lt; <a class="el" href="structthesoup_1_1types_1_1_neighbour.html">thesoup::types::Neighbour</a>&lt; std::size_t, std::size_t &gt; &gt;, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::get_neighbours </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all neighbours of a vertex. </p>
<p>This method returns all neighbours of a vertex. The returned value is a list of type Neighbour&lt;edge_type, vertex&gt;. This allows us to keep information about what neighbour is attached to this vertex by what type of edge. This function can be used with const objects of the class.</p>
<p>If the vertex is not present, an error code is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>The vertex whose neighbours to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classthesoup_1_1types_1_1_result.html" title="A class akin to Rust&#39;s Result&lt;T, E&gt;. Helps us avoid having to throw exceptions. The Result&lt;T,...">Result</a>&lt;List&lt;Neighbour&lt;vertex ID, edge type ID&gt;&gt; </dd></dl>

</div>
</div>
<a id="a1df0191bd334ccde77052b018e7db630" name="a1df0191bd334ccde77052b018e7db630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df0191bd334ccde77052b018e7db630">&#9670;&#160;</a></span>get_neighbours() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::vector&lt; std::size_t &gt;, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::get_neighbours </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>edge_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return all neighbour of a vertex, attached by a given edge type. </p>
<p>This method returns all neighbours of a given vertex, who are attached by a certain edge type only. The returned value is a list of vertex IDs. This function can be used with const objects of the class.</p>
<p>If a vertex is absent of the edge type is not registered, an error code is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td></td></tr>
    <tr><td class="paramname">edge_type</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ad5a18b746016dc415f0cd8b3d9035270" name="ad5a18b746016dc415f0cd8b3d9035270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a18b746016dc415f0cd8b3d9035270">&#9670;&#160;</a></span>hydrate_edge_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; const E_TYPE, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::hydrate_edge_type </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>edge_type_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hydrate an edge type. </p>
<p>This method accepts an edge type ID and returns the corresponding actual edge type. If the edge type is absent, an error specifying that is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge_type_id</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result&lt;edge_type, ErrorCode&gt; </dd></dl>

</div>
</div>
<a id="a3dc0b427058a4eea5f24e1b6c5b72e2f" name="a3dc0b427058a4eea5f24e1b6c5b72e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc0b427058a4eea5f24e1b6c5b72e2f">&#9670;&#160;</a></span>hydrate_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; const V_TYPE, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::hydrate_vertex </td>
          <td>(</td>
          <td class="paramtype">const std::size_t &amp;&#160;</td>
          <td class="paramname"><em>vertex_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hydrate a vertex. </p>
<p>This method accepts a vertex ID and returns the corresponding actual vertex. If the vertex is absent, an error specifying that is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex_id</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result&lt;vertex, ErrorCode&gt; </dd></dl>

</div>
</div>
<a id="a3c18209d744a2c033910c7923adb9a0d" name="a3c18209d744a2c033910c7923adb9a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c18209d744a2c033910c7923adb9a0d">&#9670;&#160;</a></span>insert_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="namespacethesoup_1_1types.html#a9f4c3e6e6ef3cad9fba1f089fd2af9a2">thesoup::types::Unit</a>, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::insert_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structthesoup_1_1types_1_1_edge.html">thesoup::types::Edge</a>&lt; std::size_t, std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an edge. </p>
<p>This function takes an edge of type <a class="el" href="structthesoup_1_1types_1_1_edge.html" title="A type representing an edge.">thesoup::types::Edge</a> with the template parameters set to std::size_t. If the vertices in the (from, edge, to) do not exist, an error is returned via the <a class="el" href="classthesoup_1_1types_1_1_result.html" title="A class akin to Rust&#39;s Result&lt;T, E&gt;. Helps us avoid having to throw exceptions. The Result&lt;T,...">thesoup::types::Result</a> type. Same, if the ID corresponding the edge is not registered previously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td>The edge to insert of the form (from vertex ID, edge ID, to vertex ID) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result&lt;Unit, ErrorCode&gt; </dd></dl>

</div>
</div>
<a id="aa79edb216c8ed3509d6f93a17306444a" name="aa79edb216c8ed3509d6f93a17306444a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79edb216c8ed3509d6f93a17306444a">&#9670;&#160;</a></span>insert_vertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::size_t, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::insert_vertex </td>
          <td>(</td>
          <td class="paramtype">const V_TYPE &amp;&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a vertex. </p>
<p>This method adds a vertex to the graph and returns an ID. The vertex does not necessarily have to be attached to another vertex. Since edge insertions are of the form (from ID, edge type, to ID), either keep this ID stored somewhere of just query the ID with the hydration API.</p>
<p>If the vertex has been already added, then the function will return a Success(previous_id). In case of a collision, the function tries to rehash using an <code>attempt_id</code> number. In the rare case the collisions are way too much and we run out of attempt ids, a failure is returned.</p>
<p>The id type is std::size_t. So on a 64 bit system, you have 2^64 collisions, you have bigger problems. This function expects to have a `struct hash with operator() defined to return a std::size_t in namespace std (a pretty standard requirement to make anything hashable).</p>
<p>Worst case complexity in case of a horrendous hash function is O(n). Example, if thee hash function is a constant, this will happen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result&lt;vertex_id, error_code&gt; </dd></dl>

</div>
</div>
<a id="a2f298b5ca1c8ee50a04113e8a5336f1c" name="a2f298b5ca1c8ee50a04113e8a5336f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f298b5ca1c8ee50a04113e8a5336f1c">&#9670;&#160;</a></span>register_edge_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename V_TYPE , typename E_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; std::size_t, IndexedPropertyDiGraphAttributes::ErrorCode &gt; <a class="el" href="classthesoup_1_1types_1_1_indexed_property_di_graph.html">thesoup::types::IndexedPropertyDiGraph</a>&lt; V_TYPE, E_TYPE &gt;::register_edge_type </td>
          <td>(</td>
          <td class="paramtype">const E_TYPE &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an edge. </p>
<p>This method registers an edge type and returns an ID for the registered edge type. Subsequent additions of edges will be of the type (from vertex ID, edge type, to vertex ID). As mentioned before, this is really helpful when the edge types are large structs. This allows all operations other than the hydration to be on long integers, making them efficient.</p>
<p>If the edge type has been already registered, then the function will return a Success(previous_id). In case of a collision, the function tries to rehash using an <code>attempt_id</code> number. In the rare case the collisions are way too much and we run out of attempt ids, a failure is returned.</p>
<p>The id type is std::size_t. So on a 64 bit system, you have 2^64 collisions, you have bigger problems. This function expects to have a `struct hash with operator() defined to return a std::size_t in namespace std (a pretty standard requirement to make anything hashable).</p>
<p>Worst case complexity in case of a horrendous hash function is O(n). Example, if the hash function is a constant, this will happen.</p>
<p>Average case complexity with a good hash function should be O(1).</p>
<p>NOTE: Once registered, an edge type cannot be unregistered, as it might leave the graph as inconsistent</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result&lt;edge_type_id, error_code&gt; </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>headers/thesoup/types/<a class="el" href="indexedgraph_8hpp_source.html">indexedgraph.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
