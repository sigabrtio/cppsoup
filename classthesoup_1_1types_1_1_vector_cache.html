<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Numeric: thesoup::types::VectorCache&lt; T, page_offset_bits, page_index_bits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Numeric<span id="projectnumber">&#160;0.1</span>
   </div>
   <div id="projectbrief">A C++ numeric library.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacethesoup.html">thesoup</a></li><li class="navelem"><a class="el" href="namespacethesoup_1_1types.html">types</a></li><li class="navelem"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">VectorCache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classthesoup_1_1types_1_1_vector_cache-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">thesoup::types::VectorCache&lt; T, page_offset_bits, page_index_bits &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A cached vector implementation.  
 <a href="classthesoup_1_1types_1_1_vector_cache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector__cache_8hpp_source.html">vector_cache.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3162fc1eff0e19d3ec3e149a023b4869"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#a3162fc1eff0e19d3ec3e149a023b4869">VectorCache</a> (const std::function&lt; <a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; bool, int &gt;(const <a class="el" href="structthesoup_1_1types_1_1_slice.html">thesoup::types::Slice</a>&lt; T &gt; &amp;, const std::size_t &amp;page_num)&gt; &amp;saver, const std::function&lt; <a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="structthesoup_1_1types_1_1_slice.html">thesoup::types::Slice</a>&lt; T &gt;, int &gt;(const std::size_t &amp;)&gt; &amp;loader)</td></tr>
<tr class="memdesc:a3162fc1eff0e19d3ec3e149a023b4869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a3162fc1eff0e19d3ec3e149a023b4869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52fbd56a7eace57439447c398286248"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#ad52fbd56a7eace57439447c398286248">~VectorCache</a> ()</td></tr>
<tr class="memdesc:ad52fbd56a7eace57439447c398286248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:ad52fbd56a7eace57439447c398286248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf47da745d19114f7a1d6c15becea249"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#adf47da745d19114f7a1d6c15becea249">VectorCache</a> (<a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt; &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:adf47da745d19114f7a1d6c15becea249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:adf47da745d19114f7a1d6c15becea249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28d8550472023e4d253ccb7cf7795c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#ac28d8550472023e4d253ccb7cf7795c6">push_back</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:ac28d8550472023e4d253ccb7cf7795c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push an item onto the vector.  <br /></td></tr>
<tr class="separator:ac28d8550472023e4d253ccb7cf7795c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2e22221e9081e3512e956a7acf475e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#a5b2e22221e9081e3512e956a7acf475e">operator[]</a> (const std::size_t idx)</td></tr>
<tr class="memdesc:a5b2e22221e9081e3512e956a7acf475e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The random access operator.  <br /></td></tr>
<tr class="separator:a5b2e22221e9081e3512e956a7acf475e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcaeace4a3e6dc108e980e8be453a87e"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#abcaeace4a3e6dc108e980e8be453a87e">size</a> () const noexcept</td></tr>
<tr class="memdesc:abcaeace4a3e6dc108e980e8be453a87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of elements in the vector.  <br /></td></tr>
<tr class="separator:abcaeace4a3e6dc108e980e8be453a87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61232d062ee97b655055f00db7b55971"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#a61232d062ee97b655055f00db7b55971">bytes</a> () const noexcept</td></tr>
<tr class="memdesc:a61232d062ee97b655055f00db7b55971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total bytes being used.  <br /></td></tr>
<tr class="separator:a61232d062ee97b655055f00db7b55971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ec977cad3f80d77c714f3b8622b8e6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#a23ec977cad3f80d77c714f3b8622b8e6">num_partitions</a> () const noexcept</td></tr>
<tr class="memdesc:a23ec977cad3f80d77c714f3b8622b8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of pages.  <br /></td></tr>
<tr class="separator:a23ec977cad3f80d77c714f3b8622b8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad029ebbe0c6dc27fd42cc4d3613791f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structthesoup_1_1types_1_1_slice.html">thesoup::types::Slice</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html#ad029ebbe0c6dc27fd42cc4d3613791f6">get_partition</a> (const std::size_t page_number)</td></tr>
<tr class="memdesc:ad029ebbe0c6dc27fd42cc4d3613791f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the slice for a partition.  <br /></td></tr>
<tr class="separator:ad029ebbe0c6dc27fd42cc4d3613791f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af212b54eb4cf5b4845b3f2c68523fc9e"><td class="memItemLeft" align="right" valign="top"><a id="af212b54eb4cf5b4845b3f2c68523fc9e" name="af212b54eb4cf5b4845b3f2c68523fc9e"></a>
Iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:af212b54eb4cf5b4845b3f2c68523fc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62c2f1211fae92f02b33b857f343a40"><td class="memItemLeft" align="right" valign="top"><a id="aa62c2f1211fae92f02b33b857f343a40" name="aa62c2f1211fae92f02b33b857f343a40"></a>
Iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:aa62c2f1211fae92f02b33b857f343a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt;<br />
class thesoup::types::VectorCache&lt; T, page_offset_bits, page_index_bits &gt;</div><p>A cached vector implementation. </p>
<p>Ever wished you had a data structure that behaved like a vector, but you have the capability to load only a part of it into memory at a time? A sort of memory managed std::vector? Me neither! Here is a data structure that can do that anyway!</p>
<p>The <a class="el" href="classthesoup_1_1types_1_1_vector_cache.html" title="A cached vector implementation.">VectorCache</a> class has the ability to do just that. This class emulates a 1 way set associative caching mechanism to allow a part of the vector to be saved to memory. Here is an explaination of how that works.</p>
<p>Say you want a page size of N, and you want M pages saved in memory. NOTE: N and M can only be powers of 2, for reasons that will become clear later.</p>
<p>Consider a 64 bit index into our vector. Since the page size (N) is a power of 2, we will need a K bit number to address anything inside of a page, where 2^K = N.</p>
<p>The remaining 64 - K bits will constitute the page number, allowing us to have 2 ^ (64 - K) pages. We use a page table to keep records of which page is saved where in the memory. Now we probably do not want ALL the pages in memory (we want M of them), so a M sized page table is good enough. If you recall, M is also a power of 2. Hence we can index into the page table using R bits where (2^R) = M.</p>
<p>Given this, we will use R of the remaining (64 - K) bits from a item's index to figure out where exactly in the page table, we can find the information about the page where our element resides.</p>
<p>To recap, when we do <code>my_arr[idx]</code>,</p><ul>
<li>First we split up the idx into 3 parts:<ul>
<li>Offset bits (lowest K bits)</li>
<li>Index bits (Lowest K+R bits to lowest K bits)</li>
<li>Tag bits (The highest remaining bits that we do not care about)</li>
</ul>
</li>
<li>We first use the index bits to query the page table to get in formation about the page with a page number equal to the <code>idx</code> with the lowest K bits masked to 0.</li>
<li>Note that many different pages can map to the same page table entry. Specifically 2^(64-K-R) pages can map to the same page table entry. So, if we detect that the wrong page is loaded, we save that page somewhere and load the correct one (swap).</li>
<li>If we find that this page was never loaded at all (the page table is entry is invalid), we will just load the relevant page from somewhere and fix the page table entry.</li>
<li>Now that we have the page information, we need to go to the memory location where the page is loaded, and index into that using the page offset bits, to retrieve the final element.</li>
</ul>
<p>Notes:</p><ul>
<li>How to save and load a page is specified by the user via a <code>saver</code> and <code>loader</code> function. The saver function, when called will be handed a memory slice (<a class="el" href="structthesoup_1_1types_1_1_slice.html" title="A class akin to python/rust Slice type (a fat pointer).">thesoup::types::Slice</a>), and the actual page number. This function has the responsibility of storing the data in a way that can be retrieved later. Similarly, the load function is just provided a page number and must return a slice (<a class="el" href="structthesoup_1_1types_1_1_slice.html" title="A class akin to python/rust Slice type (a fat pointer).">thesoup::types::Slice</a>) after loading the data to memory. Use MYSQL, local file or whatever suits you for offloading pages.</li>
<li>Keeping the page size and number of pages powers of 2, by defining them as exponents of 2 help us keep the computations of page number and page offset fast. We just rely on bitwise operations as opposed to expensive modulo arithmetic.</li>
<li>DO NOT expect performance of the <code>[]</code> operator iterators even remotely close to std::vector. Each operation requires a LOT of extra computations as compared to a plain std::vector.</li>
<li>However if you are working locally within a page, and want fast access, this class does provides methods that with return a slice corresponding to an index. Then use the slice to access elements i the page.</li>
<li>Copy constructor, and both copy and move assignment operators have been deleted. Copying incurs a massive headache as we not only have to copy all the loaded slices, but also whatever the hell is offloaded via the <code>save</code> method. Assignment operators have been deleted for this reason + the fact that even in case of move assignment, we will have to clean up the original object.</li>
</ul>
<p>Usage: </p><div class="fragment"><div class="line"><a class="code hl_class" href="classthesoup_1_1types_1_1_vector_cache.html">VectorCache&lt;int, 4&gt;</a> my_vec;</div>
<div class="line">my_vec.<a class="code hl_function" href="classthesoup_1_1types_1_1_vector_cache.html#ac28d8550472023e4d253ccb7cf7795c6">push_back</a>(1);</div>
<div class="line">my_vec.<a class="code hl_function" href="classthesoup_1_1types_1_1_vector_cache.html#ac28d8550472023e4d253ccb7cf7795c6">push_back</a>(2);</div>
<div class="line">my_vec.<a class="code hl_function" href="classthesoup_1_1types_1_1_vector_cache.html#ac28d8550472023e4d253ccb7cf7795c6">push_back</a>(3);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; item : my_vec) {</div>
<div class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="aclassthesoup_1_1types_1_1_vector_cache_html"><div class="ttname"><a href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a></div><div class="ttdoc">A cached vector implementation.</div><div class="ttdef"><b>Definition:</b> vector_cache.hpp:113</div></div>
<div class="ttc" id="aclassthesoup_1_1types_1_1_vector_cache_html_ac28d8550472023e4d253ccb7cf7795c6"><div class="ttname"><a href="classthesoup_1_1types_1_1_vector_cache.html#ac28d8550472023e4d253ccb7cf7795c6">thesoup::types::VectorCache::push_back</a></div><div class="ttdeci">void push_back(const T &amp;item) noexcept</div><div class="ttdoc">Push an item onto the vector.</div><div class="ttdef"><b>Definition:</b> vector_cache.hpp:201</div></div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The success type. </td></tr>
    <tr><td class="paramname">page_offset_bits</td><td>The page size exponent. The page size will be therefore 2^page_offset_bits, and the number of bytes a page can hold will be page_size * sizeof(T) </td></tr>
    <tr><td class="paramname">page_index_bits</td><td>The page table index exponent. The page table size will be therefore 2^page_index_bits, implying that the total in-memory capacity of the vector cache class will be page table size * page size * sizeof (T) </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3162fc1eff0e19d3ec3e149a023b4869" name="a3162fc1eff0e19d3ec3e149a023b4869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3162fc1eff0e19d3ec3e149a023b4869">&#9670;&#160;</a></span>VectorCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::VectorCache </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; bool, int &gt;(const <a class="el" href="structthesoup_1_1types_1_1_slice.html">thesoup::types::Slice</a>&lt; T &gt; &amp;, const std::size_t &amp;page_num)&gt; &amp;&#160;</td>
          <td class="paramname"><em>saver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classthesoup_1_1types_1_1_result.html">thesoup::types::Result</a>&lt; <a class="el" href="structthesoup_1_1types_1_1_slice.html">thesoup::types::Slice</a>&lt; T &gt;, int &gt;(const std::size_t &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>loader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saver</td><td>The saver function as described above, is responsible for saving pages during swaps / object destruction. </td></tr>
    <tr><td class="paramname">loader</td><td>The loader function, as described above, is responsible for loading a page from persistence on a swap. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad52fbd56a7eace57439447c398286248" name="ad52fbd56a7eace57439447c398286248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52fbd56a7eace57439447c398286248">&#9670;&#160;</a></span>~VectorCache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::~<a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">VectorCache</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>The destructor actually flushes all the pages in memory before destroying the page table contents, and the in memory stuff. </p>

</div>
</div>
<a id="adf47da745d19114f7a1d6c15becea249" name="adf47da745d19114f7a1d6c15becea249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf47da745d19114f7a1d6c15becea249">&#9670;&#160;</a></span>VectorCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::VectorCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<p>Move constructor. Please do not try to use the object out of which everything was just moved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The object from which to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a61232d062ee97b655055f00db7b55971" name="a61232d062ee97b655055f00db7b55971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61232d062ee97b655055f00db7b55971">&#9670;&#160;</a></span>bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total bytes being used. </p>
<p>This method returns the total number of bytes (loaded in memory or not) being used. Note that once a page is allocated, it might not be full. So the total bytes being used might be greater than total number of elements multiplied by the size of each element.</p>
<dl class="section return"><dt>Returns</dt><dd>Total bytes (std::size_t) </dd></dl>

</div>
</div>
<a id="ad029ebbe0c6dc27fd42cc4d3613791f6" name="ad029ebbe0c6dc27fd42cc4d3613791f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad029ebbe0c6dc27fd42cc4d3613791f6">&#9670;&#160;</a></span>get_partition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthesoup_1_1types_1_1_slice.html">thesoup::types::Slice</a>&lt; T &gt; <a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::get_partition </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>page_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the slice for a partition. </p>
<p>As mentioned before, both random, and sequential access is slow for this class, as a large number of computations need to be made. However if one id working mostly within a page (spatial locality) and needs performance, he can extract the slice information for a page and and then work with that. That will provide full performance of that of std::vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page_number</td><td>The page number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A slice for that partition </dd></dl>

</div>
</div>
<a id="a23ec977cad3f80d77c714f3b8622b8e6" name="a23ec977cad3f80d77c714f3b8622b8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23ec977cad3f80d77c714f3b8622b8e6">&#9670;&#160;</a></span>num_partitions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::num_partitions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of pages. </p>
<p>This method returns the total number of pages, regardless of whether they are in memory or not.</p>
<dl class="section return"><dt>Returns</dt><dd>Total number of pages (std::size_t) </dd></dl>

</div>
</div>
<a id="a5b2e22221e9081e3512e956a7acf475e" name="a5b2e22221e9081e3512e956a7acf475e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2e22221e9081e3512e956a7acf475e">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T &amp; <a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The random access operator. </p>
<p>This operator allows us to access the ith element like this: array[i]. This is just like the <code>[]</code> operator of std::vector, except that this can be very slow, when a swap is needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index to access </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the idx-th element in the vector. </dd></dl>

</div>
</div>
<a id="ac28d8550472023e4d253ccb7cf7795c6" name="ac28d8550472023e4d253ccb7cf7795c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28d8550472023e4d253ccb7cf7795c6">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push an item onto the vector. </p>
<p>Appends one item to the end of the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to push onto the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abcaeace4a3e6dc108e980e8be453a87e" name="abcaeace4a3e6dc108e980e8be453a87e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcaeace4a3e6dc108e980e8be453a87e">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , PageOffsetBits::type page_offset_bits, PageIndexBits::type page_index_bits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classthesoup_1_1types_1_1_vector_cache.html">thesoup::types::VectorCache</a>&lt; T, page_offset_bits, page_index_bits &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of elements in the vector. </p>
<p>This method returns the TOTAL number of elements in the vector, regardless of whether they are loaded in memory or not.</p>
<dl class="section return"><dt>Returns</dt><dd>Total number of elements (std::size_t) </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>headers/thesoup/types/<a class="el" href="vector__cache_8hpp_source.html">vector_cache.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
